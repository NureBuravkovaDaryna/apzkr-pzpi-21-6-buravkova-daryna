Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
Факультет комп’ютерних наук 
Кафедра програмної інженерії 
КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система управління, роботи та відстеження автоматів з кавою 
Студент гр. ПЗПІ-21-6       ________________ Буравкова Д.А. 
(підпис) 
Керівник роботи                 ________________ ст.викл. Сокорчук І.П.
(підпис)  
Роботу захищено «__»_________2024 р. 
з оцінкою _________________________  
Комісія:                                  ______________ доц. Лещинський В.О.  
(підпис) 
_______________ доц. Лещинська І.О.  
(підпис)
_______________ ст.викл. Сокорчук І.П. 
(підпис) 

Харків  
2024 р. 

Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6	 Навчальна дисципліна Архітектура програмного забезпечення	 

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Буравковій Дарині Андріївні
Тема роботи: «Програмна система управління, роботи та відстеження автоматів з кавою» 	
Термін узгодження завдання курсової роботи  «01»  квітня  2024 р.
Термін здачі студентом закінченої роботи « »             2024 р.
Вихідні дані до проекту (роботи): В програмній системі передбачити: ведення бази даних автоматів, кавових напоїв, моніторинг рівня запасів і статусу автомата, можливість замовлення кави, додавання та оновлення товарів, налаштування параметрів автоматів і аналіз статистики використання. Використовувати ОС Windows 10, СКБД Microsoft SQL Server 2022, середовище розробки Microsoft Visual Studio 2022	
Зміст  пояснювальної   записки (перелік  питань,  що	 належить розробити) вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки								
Перелік графічного матеріалу (діаграми, рисунки, інтерфейси)  UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних (діаграма), UML діаграма станів, UML діаграма діяльності, UML діаграма компонент, копії екранів (“скріншоти”) прикладної програми	


КАЛЕНДАРНИЙ ПЛАН

№   Назва етапів курсової роботи	Термін виконання етапів роботи	Примітка
1   Функціональна специфікація  програмного проекту   01.04.2024 – 07.04.2024   Виконано
2   Проектування програмного  проекту   07.04.2024 – 14.04.2024   Виконано
3   Кодування програмного проекту    14.04.2024 – 30.05.2024   Виконано
4   Оформлення пояснювальної  записки   30.05.2023 – 10.06.2024   Виконано
5   Захист курсової роботи   10.06.2024 – 17.06.2024   Виконано

Дата видачі теми проєкту         «01»    квітень    2024 р.

Керівник	 	ст.викл. Сокорчук І.П.
           (підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІ-21-6	 		Буравкова Д.А. 
			(підпис)


РЕФЕРАТ


Пояснювальна записка до курсового проектування: 85 с., 52 рис., 1 табл., 6 джерел, 4 додатка.
АВТОМАТ, НАПІЙ, КОНТРОЛЬ, БАЗА ДАНИХ, АДМІНІСТРАТОР, REACT JS, C#, KOTLIN, ENTITY FRAMEWORK, MS SQL SERVER, VISUAL STUDIO 2022.
Метою цього курсового проекту є розробка інформаційної системи для управління, роботи та відстеження автоматів з кавою, а також створення панелі адміністратора для контролю автоматів та інтерфейсу користувачів для перегляду детальної інформації про автомати та напої.
Методи розробки базуються на використанні середовища розробки Microsoft Visual Studio 2022, СУБД MS SQL Server, ADO.NET Entity Framework та мови програмування C# для серверної частини,  Visual Studio Code та мови програмування JS для клієнтської частини, Android Studio  та мови програмування Kotlin для мобільного додатка.
В результаті отриманий програмний продукт «Програмна система управління, роботи та відстеження автоматів з кавою», який забезпечує зручну роботу адміністраторів системи і підвищує їх продуктивність та взаємодію клієнтів з системою. 


ЗМІСТ


ВСТУП	7
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Аналіз предметної області	8
1.2 Аналіз існуючих аналогів	9
1.3 Потреби клієнтів та ринку	10
2 ПОСТАНОВКА ЗАДАЧІ	12
2.1   Окреслення концепції	12
2.2 Концептуальне моделювання	13
2.3  Головна функціональність	15
2.4  Рамки первинного випуску	16
2.5  Рамки наступних випусків	17
3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ	19
3.1   Опис загальної архітектури системи	19
3.2  Структура бази даних	20
3.3  Архітектура серверної частини	22
3.4  Архітектура клієнтського застосунку	24
3.5  Архітектура мобільного застосунку	28
4 ПРОГРАМНА РЕАЛІЗАЦІЯ	31
4.1  Реалізація серверної частини	31
4.2  Реалізація клієнтського застосунку	35
4.3  Реалізація мобільного застосунку	36
5 ОПИС РЕАЛІЗОВАНОЇ СИСТЕМИ	38
5.1  Опис серверної частини	38
5.2  Опис клієнтського застосунку	38
5.3  Опис мобільного застосунку	59
ВИСНОВКИ	65
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	66
ДОДАТОК А	67
ДОДАТОК Б	72
ДОДАТОК В	79
ДОДАТОК Г	85


ВСТУП


У світі стрімко зростає популярність кавових автоматів, що надають можливість швидкого та зручного отримання кавових напоїв. За останні кілька років споживання кави поза кав'ярнями значно збільшилося, що спонукає багатьох підприємців та офісні організації розглядати можливість встановлення кавових автоматів на своїх територіях. Проте, управління та обслуговування таких автоматів може бути складним завданням. Часто виникають проблеми з моніторингом рівня запасів, плануванням технічного обслуговування, а також забезпеченням зручного замовлення напоїв. Аналіз ринку показав, що існуючі методи обслуговування клієнтів у сфері кавових автоматів залишають бажати кращого, і це стала основою для створення програмної системи.
Головною ідеєю розробки програмного продукту є створення інноваційної системи управління автоматами з кавою, яка дозволить забезпечити зручний та ефективний процес замовлення кави для клієнтів, а також оптимізувати управління автоматами для адміністраторів. 
Програмний продукт має на меті покращити користувацький досвід та збільшити ефективність управління автоматами з кавою в різних закладах та офісах. Система дозволить підвищити рівень автоматизації та забезпечити розширені можливості моніторингу та управління автоматами, що відповідатиме сучасним вимогам ринку та сприятиме покращенню сервісу для клієнтів.


1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Аналіз предметної області


Популярність кавових автоматів зростає з кожним роком, про що свідчить їх широке використання в різних місцях: офісах, готелях, аеропортах, торгових центрах та інших громадських місцях. Вони не тільки забезпечують швидкий доступ до кави, але й стають важливою частиною простору для спілкування, відпочинку та ділових зустрічей.
При аналізі предметної області необхідно враховувати ряд факторів, які впливають на функціонування кавових автоматів. Насамперед, важливо враховувати тенденції ринку і споживчий попит на якісні напої. Розмаїття смакових уподобань споживачів вимагає широкого асортименту кавових напоїв для вибору. До того ж, зростаючий попит на споживання кави та збільшення кількості закладів харчування створюють попит на кавові автомати в різних місцях, від офісів до торгових центрів та громадських місць.
Ключовою проблемою для користувачів кавових автоматів є необхідність знайти найближчий автомат з якісною кавою. Це особливо актуально в сучасних міських умовах, де швидкість і зручність мають неабияке значення. Отже, існує потреба в інформаційній системі, яка дозволить користувачам легко знаходити та відстежувати кавові автомати в їхньому районі.
Окрім того, така система може бути актуальною для адміністраторів кавових автоматів, щоб відстежувати їх роботу, проводити технічне обслуговування та своєчасно поповнювати запаси інгредієнтів.
Розуміння потреб користувачів у пошуку та використанні кавових автоматів є ключовим для розробки зручного та високоефективного програмного забезпечення для управління автоматами. Система повинна бути простою у використанні, надійною та забезпечувати швидкий доступ до актуальної інформації про місцезнаходження автоматів, їхній стан та асортимент напоїв.


1.2 Аналіз існуючих аналогів


На ринку існують деякі аналогічні рішення для пошуку та управління кавовими автоматами, проте їхні можливості та функціонал обмежені. 
Одним із досить популярних рішень є «VendSoft». Це програмне забезпечення для управління автоматами з продажу, включаючи кавові автомати. Система забезпечує облік товарів, управління маршрутами обслуговування, аналітику продажів та інвентаризацію. Проте, висока функціональність системи може стати викликом для користувачів, особливо для тих, хто не має достатнього досвіду в управлінні подібними системами. Також VendSoft може мати обмежені можливості для інтеграції з іншими системами, що може бути важливим для великих компаній, які використовують різні програмні рішення.
«CoffeeFinder» - додаток, який спеціалізується на пошуку кавових автоматів. Він дозволяє користувачам не лише знаходити автомати, але й отримувати інформацію про їхній стан, наявність напоїв та технічні проблеми. Додаток також надає можливість отримувати сповіщення про поповнення запасів у автоматах, що особливо корисно для офісних працівників та студентів. Однак деякі користувачі відзначають, що інтерфейс додатку може бути перевантаженим і складним для нових користувачів.
Основними перевагами розроблюваного програмного продукту над існуючими аналогами є постійне оновлення даних про розташування та стан автоматів з кавою. Використання сучасних технологій моніторингу та інтеграції з іншими сервісами дозволить надавати користувачам максимально точну та актуальну інформацію. Для операторів автоматів буде розроблена спеціальна панель адміністрування, яка дозволить ефективно керувати мережею автоматів: відстежувати стан обладнання, планувати технічне обслуговування, аналізувати попит на напої та оптимізувати логістику.


1.3 Потреби клієнтів та ринку


Основною потребою клієнтів є забезпечення простоти, зручності та швидкості процесу замовлення кави. Вони хочуть мати можливість отримати свій улюблений напій миттєво, без зайвих зусиль та затрат. Досить часто, особливо в офісних середовищах або на публіці, очікування у черзі до автомата з кавою може витрачати значний час, що негативно впливає на враження та загальний комфорт користувачів. Тому основна потреба полягає в тому, щоб зробити процес отримання кави якомога швидким та доступним.
Крім того, адміністратори виявляють потребу у віддаленому моніторингу та керуванні кавовими автоматами. Вони бажають мати можливість перевіряти запаси інгредієнтів, вести облік про несправності та створювати необхідні налаштування для автоматів через систему. Це особливо важливо для власників бізнесу або адміністраторів, які мають велику кількість автоматів та бажають ефективно контролювати їхню роботу.
На ринку існує попит на інноваційні рішення, які дозволять оптимізувати процеси замовлення та обслуговування кавових автоматів. Клієнти очікують від продукту не лише зручності, а й надійності, ефективності та інноваційності. Вони бажають мати можливість використовувати інтегровану систему, яка пропонує широкий функціонал та забезпечує максимальний комфорт у використанні.
Задоволення цих потреб є важливими для наших користувачів та допомагає створити продукт, який відповідає на реальні вимоги ринку.


2 ПОСТАНОВКА ЗАДАЧІ
2.1   Окреслення концепції


Програмна система має на меті створити інтегроване рішення, яке дасть користувачам можливість швидкого та зручного пошуку необхідних автоматів з кавою у будь-якому місці.
Основною метою програмної системи є створення інтегрованого рішення для управління, роботи та відстеження автоматів з кавою, що сприятиме покращенню якості обслуговування та задоволенню потреб користувачів. Завдяки створенню зручного та надійного інструмента, користувачі зможуть швидко знаходити необхідні автомати, отримувати актуальну інформацію про їхній стан та асортимент, а також залишати відгуки та оцінки.
В основі концепції цієї системи лежить ідея забезпечення максимальної зручності та ефективності як для звичайних користувачів, так і для адміністраторів кавових автоматів. Для цього створюється інтуїтивно зрозумілий інтерфейс, який дозволить користувачам швидко і легко знаходити потрібну інформацію і виконувати необхідні дії. Крім того, для адміністраторів буде створено потужні інструменти управління, які дозволять їм ефективно керувати мережею кавових автоматів і забезпечувати її безперебійну роботу.
Переваги впровадження цієї програмної системи полягають у покращенні якості обслуговування для користувачів. Завдяки актуальній інформації про стан та розташування автоматів, користувачі зможуть швидко знаходити найближчі автомати з кавою та отримувати необхідний напій без зайвих зусиль. До того ж, за допомогою системи моніторингу та сповіщень, адміністратори зможуть оперативно реагувати на будь-які проблеми з автоматами, що дозволить підтримувати їх у працездатному стані та забезпечити неперервне обслуговування.
Загальна перевага впровадження цього продукту полягає в підвищенні ефективності та задоволення потреб користувачів. Швидкий доступ до інформації про автомати з кавою, можливість залишати відгуки та отримувати сповіщення про їх стан дозволить користувачам зробити свідомий вибір та отримати якісний сервіс. Водночас, адміністратори матимуть змогу ефективно керувати мережею автоматів та забезпечити їх найвищу продуктивність. Таким чином, впровадження цього продукту сприятиме зростанню задоволеності користувачів, оптимізації роботи адміністраторів та покращенню загального обслуговування.


2.2 Концептуальне моделювання


Розглянемо ключові моменти щодо функціонування та структури системи з точки зору взаємодії з користувачами, обробки даних та бізнес-процесів. Це відіграє важливу роль у проектуванні системи, яка відповідає цілям і вимогам користувачів. Розроблена програмна система охоплює три основні ролі користувачів: адміністратор, технічний спеціаліст і клієнт. Інформаційні потреби цих груп користувачів представлені на детальній Use-case діаграмі (див. рис. 2.1). На ній відображено усі можливі дії користувачів.

Рисунок 2.1 – Use-case діаграма для опису інформаційних потреб

Крім основних потреб, усі користувачі інформаційної системи повинні мати інструменти пошуку та фільтрації:
	-адміністратор, що потребує детальної інформації про автомати та замовлення → потреба в можливості пошуку автоматів за назвою автомату або фільтрації за місцезнаходженням, а замовлення за його номером;
	-адміністратор, що потребує детальної інформації про напої → потреба в можливості пошуку напоїв за назвою або типом напою;
	-технічний працівник, що потребує детальної інформації про власні автомати → потреба в можливості фільтрації автомобілів, які працюють (або не працюють);
	-клієнти, що потребують детальної інформації про автомати, які працюють → потреба в можливості фільтрацій автоматів за місцезнаходженням
	-клієнти, що потребують детальної інформації про напої, які можна замовити → потреба в можливості пошуку напоїв за назвою.


2.3  Головна функціональність


Головна функціональність програмного продукту складається з широкого спектру інструментів та можливостей, спрямованих на забезпечення ефективного управління, моніторингу та користування автоматами з кавою. Основні аспекти функціональності програмного продукту:
	-реєстрація та створення особистого облікового запису для користувачів;
	-пошук та фільтрація автоматів з кавою за різними критеріями, такими як місцезнаходження та тип напою;
	-можливість перегляду доступних напоїв у кожному автоматі та робити замовлення;
	-моніторинг автоматів за такими параметрами, як стан обладнання та рівень інгредієнтів у кожному автоматі;
	-можливість встановлювати параметри приготування напоїв, такі як температура, сила, об'єм тощо, для кожного автомату окремо;
	-можливість оновлювати асортимент напоїв та їх ціни;
	-відгуки та оцінки про якість напоїв.


2.4  Рамки первинного випуску


Перший випуск програмної системи буде орієнтований на найбільш важливі та необхідні функції для користувачів та адміністраторів. Під час первинного випуску продукту розглядається три основні частини: сервер, клієнтський веб-додаток та мобільний додаток для Android. Кожна з цих частин відіграє важливу роль у функціонуванні системи, забезпечуючи користувачам доступ до необхідних функцій та даних.  В рамках першого випуску будуть реалізовані функції, описані раніше, в кожній частині системи:
Серверна частина:
	-відправка запитів користувачів на авторизацію для доступу до системи;
	-управління інформацією про автомати, напої, замовлення та транзакції в базі даних;
	-обробка запитів користувачів на управління обліковими записами, включаючи створення, редагування, видалення та відновлення паролів;
	-збереження, оновлення та видалення інформації про обладнання та інгредієнти напоїв у системі;
	-реалізація бізнес-логіки, включаючи розрахунок вартості кавових напоїв;
	-управління адміністраторськими правами та моніторинг системи;
	-захист персональних даних користувачів та інформації від несанкціонованого доступу;
	-обробка запитів на пошук та фільтрацію доступних автоматів для користувачів;
	-зміна параметрів для автоматів з кавою зі сторони сервера.
Клієнтська частина:
	-реєстрація та авторизація користувачів на клієнтській стороні;
	-інтерфейс для пошуку та фільтрації доступних автоматів;
	-відображення детальної інформації про обраний напій;
	-можливість коригування параметрів напою;
	-можливість залишати відгуки та оцінки для кавових напоїв;
	-можливість моніторингу автоматів з кавою;
	-можливість перегляду всіх замовлень;
	-перегляд аналітики для кожного з автоматів.
Мобільний програмний застосунок:
	-можливість реєстрації та авторизації через мобільний додаток;
	-пошук та фільтрація доступних автоматів;
	-відображення інформації про кавові напої та їх характеристики;
	-можливість швидкого замовлення через мобільний додаток.


2.5  Рамки наступних випусків


Програмна система для управління, роботи та відстеження автоматів з кавою буде розвиватися шляхом поетапної реалізації нової функціональності та можливостей у майбутніх випусках. Для майбутніх випусків розглядається наступна функціональність:
	-розробка персоналізованих рекомендацій користувачам на основі їхніх уподобань та історії замовлень;
	-додавання нових видів напоїв та можливість налаштування інгредієнтів для персоналізованих рецептів;
	-інтеграція з GPS для визначення місцезнаходження користувача та найближчих автоматів;
	-можливість налаштовувати знижки та бонуси для постійних клієнтів або за певні умови;
	-можливість користувачів зберігати свої улюблені напої та налаштування для швидкого доступу та замовлення у майбутньому.


3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ
3.1   Опис загальної архітектури системи


Загальна архітектура системи ґрунтується на клієнт-серверній моделі з використанням мобільних додатків для покращення доступності та зручності для користувачів. Система охоплює кілька компонентів, а їх структура та розташування компонентів відображені на діаграмі розгортання на рисунку 3.1.

Рисунок 3.1 – Діаграма розгортання програмної системи

Діаграма розгортання дозволяє легко зрозуміти, як система фізично організована та які компоненти взаємодіють між собою. 
Серверна частина системи реалізована на ASP.NET Web API, який надає потужні засоби для створення веб-сервісів, які можуть бути використані клієнтськими додатками для отримання необхідної інформації. Web API сервер обробляє запити від веб-клієнта та мобільного додатка. Виконує операції з базою даних через SQL Server, який зберігає всі дані проекту, включаючи інформацію про користувачів, кавові автомати, відгуки та замовлення. 
Web-клієнт відправляє HTTP-запити до Web API сервера для отримання та оновлення даних. Отримує відповіді у форматі JSON від Web API сервера. Мобільний додаток використовує HTTP-запити для взаємодії з Web API сервером.
Ця архітектура системи забезпечує зручність та ефективність використання для різних типів користувачів та платформ, дозволяючи їм отримувати необхідну інформацію та функціональність у найзручніший спосіб. 


3.2  Структура бази даних


ER-діаграма є однієї із ключових концепцій, що застосовуються в процесі розробки баз даних. За допомогою цієї діаграми структуру даних було ретельно спроектовано, перш ніж модель була реалізована у вигляді бази даних. У розроблювальному проекті діаграма визначає взаємини між користувачами, автоматами, їх статусами та параметрами, напоями, їх відгуками, регіонами та замовленнями. На рисунку 3.2 представлено інфологічну модель бази даних, на якій відображено всі сутності бази даних, відношення між ними та атрибути.

Рисунок 3.2 – ER - діаграма

На даній діаграмі можно побачити зв'язки типу «один-до-багатьох» між сутностями: 
«Користувач» і «Замовлення», оскільки кожен клієнт може робити багато замовлень, але кожне замовлення належить лише одній певній людині; 
«Відгук» і «Кава», тому що кожен відгук може бути написаний лише одному напою, а один напій може мати декілька відгуків; 
«Автомат» і «Регіон», адже кожен автомат стоїть тільки в одному місті в певний час, а в одному й тому самому місті може знаходитися декілька автоматів; 
«Кава» і «Замовлення», так, як кожен напій може бути замовлений не один раз за весь період, а кожному замовленню належить лише один напій; 
«Замовлення» і «Автомат», оскільки кожне замовлення має конкретний автомат, в якому було зроблено замовлення, а в одному й тому самому автоматі може бути зроблено декілька замовлень, 
«Автомат» і «Технічний спеціаліст», тому що кожен автомат може обслуговувати лише один спеціаліст, а один спеціаліст може обслуговувати декілька автоматів.
Було змодельовано зв'язок типу «багато-до-багатьох» між таблицями «Кава» та «Автомат» через таблицю «Кава-Автомат», оскільки один автомат може мати багато напоїв для приготування, та один і той самий напій може готуватися у багатьох автоматах.
Також було створено ще зв'язки типу «один-до-одного» між сутностями: «Автомат» і «Статус автомата» та «Автомат» і «Параметри автомата», тому що кожному автомату відповідає лише один статус машини та одні параметри приготування, і навпаки.


3.3  Архітектура серверної частини


Для організації коду у проекті було враховано кілька архітектурних принципів для забезпечення чистоти коду та розширюваності. Програмний код в проекті розподілений на різні компоненти, використовуючи  простори імен для групування логічно пов'язаних класів. Також використовуються зовнішні бібліотеки та фреймворки, такі як Entity Framework Core, AutoMapper, і ASP.NET Core Identity, для спрощення розробки та використання готового функціоналу. Структуру програмної системи наведено на діаграмі пакетів на рисунку 3.3.

Рисунок 3.3 – Діаграма пакетів

Використання шарової архітектуру дозволило створити чистий та добре організований код. Основні шари та компоненти, які використовуються:
Data Layer - цей шар відповідає за взаємодію з базою даних. Він містить контекст бази даних, моделі даних та міграції.
Repository Layer - репозиторії використовуються для реалізації патерну репозиторіїв, який дозволяє розділити логіку доступу до даних від інших частин системи.
Interfaces Layer - цей шар містить інтерфейси, які використовуються для реалізації взаємодії між різними частинами системи та сприяють впровадженню інверсії контролю.
Controllers Layer - контролери використовуються для обробки HTTP запитів та відправлення відповідей клієнтам. Вони взаємодіють з репозиторіями та сервісами, щоб виконати операції.
DTO (Data Transfer Objects) - об'єкти передачі даних використовуються для передачі даних між різними частинами системи. Вони дозволяють нам визначити, які дані передаються через мережу та як вони представлені.
Models - моделі представляють сутності даних, які зберігаються в базі даних та використовуються для взаємодії з ними.
Helper Layer  - цей шар містить допоміжні класи та функції, які використовуються в різних частинах системи для спрощення та оптимізації коду.
Користувач взаємодіє з сервером, викликаючи методи контролерів, які групують логічно пов'язані операції. Контролери використовуються для обробки HTTP-запитів, в той час як сервіси містять бізнес-логіку. Це дозволяє дотримуватися принципу однієї відповідальності та полегшує тестування.


3.4  Архітектура клієнтського застосунку


При розробці клієнтського застосунку було використано модульну та шарову архітектуру, що дозволяє зберігати код добре організованим та легко розширюваним. З метою візуалізації структури компонентів системи та їх взаємозв'язків була створена діаграма компонентів (див. рис.3.4).

Рисунок 3.4 – UML діаграма компонентів системи 

Система використовує ряд компонентів для реалізації різноманітних функцій та забезпечення коректної взаємодії між її різними частинами. Ці компоненти співпрацюють між собою, створюючи функціонально повний та зручний для використання продукт. Вони можуть бути додані, розширені чи модифіковані в майбутньому для відповіді на розвиток системи та змінні потреби користувачів. Для візуалізації структури пакетів та їх взаємозв’язків була побудована діаграма пакетів (див.рис.3.5).

Рисунок 3.5 – UML діаграма пакетів 

Створюваний проект, що використовує React JS, має типову структуру, із специфічним акцентом на веб-розробці та взаємодії з серверною частиною за допомогою REST-запитів. 
Каталог public містить статичні файли, які безпосередньо обслуговуються веб-сервером. Основний вміст цього каталогу включає:
	-index.html: головний HTML-файл, в який React додає свої скрипти. Він містить основну структуру HTML-документа та div-контейнер з id root, в який буде вбудовано React-додаток;
	-manifest.json: файл конфігурації веб-додатка, що використовується для визначення іконок, кольорів теми та інших властивостей прогресивного веб-додатка (PWA);
	-robots.txt: файл, що інструктує веб-краулери, як сканувати сайт.
Каталог src є основним робочим каталогом для розробників, де розміщено весь вихідний код React-додатка. Його структура виглядає наступним чином:
Каталог components
Цей каталог містить окремі компоненти React, які є будівельними блоками додатка. Компоненти можуть бути повторно використані в різних частинах програми. Структура включає:
	-Navbar.js: компонент навігаційної панелі;
	-Modal.js: компонент модального вікна;
Кожен компонент має свої стилі (CSS або SCSS файли) та допоміжні файли, зберігаючи їх поруч для зручності.
Каталог pages
Каталог pages містить компоненти, що представляють окремі сторінки додатка. Вони складаються з інших компонентів та об'єднують їх для створення комплексних інтерфейсів. Приклади включають:
	-HomePage.js: головна сторінка;
	-CoffeePage.js: сторінка з переліком кавових напоїв;
	-CoffeeConcretePage.js: сторінка з деталями про конкретний кавовий напій.
Стилі
Включені стилі в різних форматах:
	-App.css: основні стилі додатка:
	-index.css: глобальні стилі;
	-Home.css: стиль сторінки додатка.
Конфігураційні файли знаходяться в кореневому каталозі проекту і забезпечують конфігурацію та управління залежностями проекту.
-package.json: файл, що містить метадані про проект, включаючи ім'я, версію, залежності, скрипти для запуску і збірки проекту та іншу конфігураційну інформацію;
-package-lock.json: файл, що фіксує конкретні версії залежностей для точного відтворення середовища розробки в майбутньому. Він гарантує, що при встановленні проекту будуть використані ті ж версії пакетів;
Залежності проекту включають різні бібліотеки та фреймворки, необхідні для розробки, тестування та збірки додатка. Основні з них:
-react: бібліотека для побудови користувацького інтерфейсу;
-react-dom: пакет для роботи з DOM у React;
-react-router-dom: бібліотека для маршрутизації в React;
-bootstrap: CSS-фреймворк для стилізації інтерфейсу;
-axios або fetch: бібліотеки для виконання HTTP-запитів.
Використання React JS у поєднанні з сучасними інструментами та бібліотеками дозволив створити високоякісний, масштабований та підтримуваний веб-додаток. Структура проекту забезпечує організованість коду, полегшує розширення функціоналу та підтримку додатка в майбутньому.


3.5  Архітектура мобільного застосунку


При розробці мобільного застосунку для платформи Android використовується мова програмування Kotlin та архітектурний паттерн MVVM (Model-View-ViewModel), що допомагає створити масштабовану, модульну та легко підтримувану архітектуру. Основні компоненти та шари мобільного застосунку наведено на малюнку 3.6.

Рисунок 3.6 – UML діаграма пакетів 

Розглянемо кожен компонент детальніше.
Activity є основним компонентом Android-застосунку, що забезпечує взаємодію користувача з екраном. Кожна Activity представляє окремий екран або вікно в застосунку. 
Fragment є підрозділами Activity, що дозволяють створювати більш динамічні та модульні інтерфейси користувача. Фрагменти дозволяють розділити логіку та інтерфейс на дрібніші частини, що можна повторно використовувати в різних Activity. Вони також взаємодіють з Activity, щоб забезпечити комплексну функціональність.
Adapter використовуються для зв'язування даних з візуальними компонентами інтерфейсу, такими як RecyclerView або ListView. Вони забезпечують зв'язок між джерелом даних (наприклад, списком автоматів з кавою) та елементами інтерфейсу, що відображають ці дані.
API (Application Programming Interface) забезпечує взаємодію мобільного застосунку з серверною частиною через мережу. API обробляє HTTP запити та відповіді, дозволяючи отримувати дані від сервера, відправляти дані на сервер та виконувати різні операції з даними для отримання списку автоматів з кавою, відправки інформації про замовлення або отримання актуальних даних про стан автоматів.
Models представляють структуру даних, які використовуються в застосунку. Вони описують, як дані виглядають та які поля містять. Моделі використовуються для зберігання та передачі даних між різними частинами застосунку. 
ViewModel відповідає за підготовку даних для відображення у відповідному View та управління їхнім станом.  Вона зберігає стан інтерфейсу при зміні конфігурацій, а також забезпечує зв'язок між моделями та представленнями. ViewModel використовує LiveData для забезпечення активної взаємодії з інтерфейсом користувача.
Ця архітектура забезпечує розділення обов'язків між різними компонентами застосунку, що сприяє його масштабованості, зручності у підтримці та розвитку.


4 ПРОГРАМНА РЕАЛІЗАЦІЯ
4.1  Реалізація серверної частини


Серверну частину програмної системи було розроблено у середовищі Microsoft Visual Studio 2022 на платформі .NET 6.0. Програмний код було написано на мові програмування C#.
Для створення легкого та ефективного веб-інтерфейсу використовується ASP.NET Core Web API, який обслуговує запити від клієнтів. Web API дозволяє створювати RESTful служби, що зробило його ідеальним вибором для взаємодії між клієнтом і сервером в створюваній програмній системі.
Entity Framework Core використовується для роботи з базою даних, забезпечуючи об'єктно-реляційне відображення (ORM). В даному випадку, було обрано Microsoft SQL Server як реляційну базу даних. EF Core спростив взаємодію з базою даних, дозволивши працювати з об'єктами .NET.
 Система авторизації та управління користувачами реалізована за допомогою ASP.NET Core Identity. Це забезпечило базову імплементацію, таку як реєстрація користувачів, автентифікація, видалення та рольовий доступ. Використовується JWT для безпечного обміну інформацією про аутентифікацію між клієнтом і сервером. Він використовується як механізм передачі токена після успішної аутентифікації, щоб дозволити клієнту отримати доступ до обмежених ресурсів. Алгоритм генерації JWT наведено у додатку В.
Всі часові мітки зберігаються у базі даних у форматі UTC. Це дозволяє уникнути проблем з різницею у часі та літнім/зимовим часом. Під час взаємодії з користувачем, сервер конвертує часові мітки з UTC у місцевий часовий пояс користувача.
Головним аспектом управління системою є адміністрування базою даних, яке включає резервне копіювання та відновлення даних, моніторинг продуктивності та безпеки. Налаштовано за допомогою інструментів, таких як SQL Server Management Studio (SSMS) та автоматизованих скриптів.
Хешування паролів є ключовим аспектом забезпечення безпеки користувацьких даних у програмній системі. Використовується криптографічний алгоритм HMACSHA512 для хешування паролів, який використовує ключ для створення криптографічного хешу. Це забезпечує додатковий рівень безпеки в порівнянні з простою хеш-функцією.
Система взаємодії із серверною частиною розроблена відповідно до архітектурного стилю REST (Representational State Transfer). У даній системі REST API визначає низку кінцевих точок, які дозволяють клієнтам взаємодіяти з сервером. Кожна кінцева точка відповідає певному функціоналу чи операції. Усі деталі та описи доступних операцій REST API подано в таблиці 1. Фрагменти коду для серверної частини подано у додатку А.

Таблиця 1 – Специфікація REST   Метод   Деталі   Опис
POST   /api/Admin/BackupDatabase   Створити бекап бази даних
GET    /api/Admin/LastBackupDate   Отримати дату останнього бекапу
POST   /api/Admin/RestoreDatabase   Відновити базу даних
POST   /api/Auth/Login   Авторизація користувача
POST   /api/Auth/Register   Реєстрація користувача
POST   /api/Auth/RegisterTechnician   Реєстрація технічного спеціаліста

Продовження таблиці 1
POST   /api/Auth/RegisterAdmin   Реєстрація адміна
GET    /api/Coffee   Отримати список напоїв
POST   /api/Coffee   Створити напій
GET    /api/Coffee/id   Отримати напій за id
PUT    /api/Coffee/id   Змінити дані напою за id
DELETE /api/Coffee/id   Видалити напій
GET    /api/CoffeeMachine   Отримати напої для автоматів
GET    /api/Coffee/CofeeMachine/id   Отримати напої для конкретного автомату за id
GET    /api/Machine   Отримати автомати
POST   /api/Machine   Створити автомат
GET    /api/Machine/id   Отримати автомат за id
PUT    /api/Machine/id   Змінити дані про конкретний автомат
DELETE /api/Machine/id   Видалити автомат
GET    /api/Machine/isWorking   Отримати доступні автомати
GET    /api/Machine/Region/id   Отримати автомати за певним регіоном
GET    /api/Machine/Coffee/id   Отримати автомати з конкретним напоєм
POST   /api/Machine/Coffee   Додати напій до автомата
GET    /api/MachineParametr/id   Отримати параметр конкретного автомату
PUT    /api/MachineParametr/id   Змінити параметр конкретного автомату
GET    /api/MachineStatus/id   Отримати статус конкретного автомату

Продовження таблиці 1
PUT    /api/MachineStatus/id   Змінити статус конкретного автомату
GET    /api/MachineStatus/MachineCondition/id   Отримати стан обладнання конкретного автомату
GET    /api/Order   Отримати список замовлень 
POST   /api/Order   Створити замовлення
GET    /api/Order/id   Отримати конкретне замовлення
GET    /api/Order/User/id   Отримати список замовлень користувача
GET    /api/Region   Отримати всі регіони
POST   /api/Region   Створити регіон
GET    /api/Region/id   Отримати регіон за id
PUT    /api/Region/id   Змінити дані регіону
DELETE /api/Region/id   Видалити регіон
POST   /api/Review/Coffee/Id   Створити відгук для напою
GET    /api/Review/Coffee/Id   Отримати відгуки для напою
GET    /api/Review/AverageRating/id   Отримати середню оцінку напою
GET    /api/Technician   Отримати список технічних працівників
GET    /api/Technician/id   Отримати конкретного технічного працівника
PUT    /api/Technician/id   Змінити дані працівника
DELETE /api/Technician/id   Видалити працівника
GET    /api/User   Отримати список всіх користувачів

Продовження таблиці 1
PUT    /api/User/id   Змінити дані конкретного користувача
GET    /api/User/id   Отримати дані конкретного користувача
DELETE /api/User/id   Видалити користувача


4.2  Реалізація клієнтського застосунку


Клієнтську частину програмної системи було розроблено  використовуючи сучасні технології та інструменти для забезпечення ефективності та якості програмного продукту. Розробка велася у середовищі Visual Studio Code.
Програмний код було написано на мові програмування JavaScript, з використанням бібліотеки React JS для реалізації користувацького інтерфейсу. React JS дозволив створити ефективний та динамічний веб-додаток, а також легко інтегрувався з іншими технологіями, що полегшило розширення та підтримку коду.
Для забезпечення зручності навігації та маршрутизації в додатку використовувалася бібліотека React Router. Це дозволило створити односторінкові додатки та ефективно управляти роутингом на клієнтському боці.
Взаємодія з серверною частиною системи здійснювалася безпосередньо за допомогою відповідних REST-запитів. Для цього використовувалися стандартні засоби мови JavaScript, такі як «fetch» або бібліотеки, які полегшують роботу з відправкою та отриманням даних через HTTP-запити.
Ця комбінація інструментів дозволяє забезпечити ефективність, гнучкість та швидкість розробки, а також створити інтерфейс, який легко масштабується та відповідає вимогам користувачів. Фрагменти коду для клієнтської частини подано у додатку Б.


4.3  Реалізація мобільного застосунку


Мобільний додаток був реалізований з використанням сучасних технологій. Розробка додатку відбувалася в середовищі Android Studio, яке є найбільш поширеним та добре підтримується середовищем розробки для платформи Android.
В якості мови програмування було обрано Kotlin, яка є офіційно рекомендованою мовою для розробки додатків для Android. Kotlin пропонує вдосконалення над мовою Java, забезпечуючи більш безпечний та компактний код, а також покращує продуктивність розробника завдяки своїм функціональним можливостям та підтримці корутин.
Користувацький інтерфейс було розроблено за допомогою Android XML, який дозволяє легко описати вигляд екранів нашого додатку та їхнє розташування. Використовувалися стандартні компоненти Android, такі як TextView, Button, RecyclerView тощо. Для покращення активності та відстеження змін у даних використовувалися компоненти бібліотеки Android Jetpack, такі як LiveData та ViewModel.
Для роботи з мережевими запитами та взаємодії з сервером була використана бібліотека Retrofit. Retrofit дозволяє легко виконувати HTTP-запити до сервера та обробляти їхні відповіді. Це робить взаємодію з веб-службами більш простою та зручною.
Була використана бібліотека Gson для роботи з JSON-даними та їхнього парсингу. Gson дозволяє легко перетворювати об'єкти Kotlin у JSON-рядки та навпаки, що є важливим для обміну даними з сервером.
Усі ці технології та інструменти допомогли створити високоякісний мобільний застосунок, який забезпечує зручний та продуктивний досвід користувача. Фрагменти коду для мобільного застосунку подано у додатку В.


5 ОПИС РЕАЛІЗОВАНОЇ СИСТЕМИ
5.1  Опис серверної частини


Серверна частина системи є центральною складовою, яка забезпечує обробку запитів від клієнтських додатків, управління базою даних та надання необхідних сервісів для коректного функціонування програмної системи управління, роботи та відстеження автоматів з кавою.
Запуск серверу відбувається на локальній машині за допомогою певного серверного середовища, такого як ASP.NET. 
Серверна частина обробляє HTTP-запити від клієнтських застосунків, включаючи запити на реєстрацію, авторизацію, пошук автоматів з кавою, замовлення напоїв та інші.
Для документації та тестування API серверної частини може бути використано Swagger або Postman. Swagger генерує інтерактивну документацію API, яка дозволяє розробникам легко ознайомитися з функціоналом та параметрами кожного ендпоінту. Postman дозволяє вручну виконувати HTTP-запити та перевіряти їх результати.


5.2  Опис клієнтського застосунку


Клієнтський застосунок, реалізований з використанням фреймворку React, надає користувачеві динамічний та інтерактивний інтерфейс для системи управління, роботи та відстеження автоматів з кавою.
Для запуску веб-додатку на клієнтському пристрої необхідно спершу встановити всі необхідні залежності та налаштувати середовище розробки. Після цього можна запустити веб-додаток за допомогою команди npm start, яка автоматично запустить локальний сервер та відкриє веб-додаток(див рис. 5.1) у вибраному браузері.

Рисунок 5.1 – Головна сторінка веб-додатку

Клієнтський застосунок має функціонал для трьох різних ролей: адміністратора, технічного працівника та звичайного користувача.
Спершу розглянемо функціонал для адміністратора. Поведінка системи зі сторони адміністратора може бути описана через різноманітні дії та можливості, які він має у системі (див. рис. 5.2).

Рисунок 5.2 – UML діаграма діяльності для адміністратора

Ця діаграма діяльності може служити інструментом для адміністратора для взаємодії з системою, а також для відстеження та керування різними аспектами її роботи. 
Для того щоб зайти до панелі адміністратора необхідно на головній сторінці натиснути кнопку «Авторизуватися», після чого відкривається сторінка для авторизації (див.рис. 5.3), де необхідно ввести дані адміністратора.

Рисунок 5.3 – Сторінка авторизації

Після успішної авторизації відкривається панель адміністратора, яка надає йому інтерфейс для різноманітних дій. Тут є бокова навігаційна панель, яка дає змогу переключатися між сторінками. Перша це робота з базою даних (див. рис. 5.4), а саме: створення резервної копії бази даних та відновлення даних з останньої резервної копії. Для цих дій адміністратору необхідно в спеціальному полі ввести назву бази даних.

Рисунок 5.4 – Сторінка керування базою даних

Наступна сторінка надає адміністратору інформацію про всі замовлення системи (див. рис. 5.5). На цій сторінці є можливість шукати замовлення за його номером, та фільтрувати замовлення за датами (див. рис. 5.6).

Рисунок 5.5 – Сторінка замовлень системи

Рисунок 5.6 – Фільтрація замовлень за датами

Далі йде сторінка зі всіма автоматами з кавою (див. рис. 5.7). На цій сторінці можна шукати автомати за назвою або адресою, також є дві кнопки для створення нового автомату (див. рис. 5.8) та створення локації (див. рис. 5.9).

Рисунок 5.7 – Сторінка з автоматами

Рисунок 5.8 – Форма для створення нового автомата

Рисунок 5.9 – Форма для створення нової локації

Для того щоб переглянути детальну інформацію про автомат необхідно натиснути кнопку «Переглянути детальніше» на картці з автоматом. Після натискання цієї кнопки відкривається сторінка з детальною інформацією про автомат (див. рис. 5.10). На цій сторінці крім інформації про автомат, ми ще можемо відредагувати дані автомату, змінити технічного спеціаліста, який відповідає за автомат, та додати до асортименту автомата новий напій з існуючих у базі даних (див. рис. 5.11).

Рисунок 5.10 – Сторінка автомата

Рисунок 5.11 – Додавання напою до автомата

Якщо прогорнути сторінку вниз, можна побачити параметри машини, які можна змінити (див.рис. 5.12), та статус машини, який відображає рівень запасів у автоматі.

Рисунок 5.12 – Зміна параметрів автомата

В самомі кінці сторінки є таблиця на якій відображено всі напої, які присутні у даному автоматі з кавою (див. рис. 5.13).

Рисунок 5.13 – Напої в автоматі

Наступною йде сторінка з напоями (див. рис. 5.14). На цій сторінці можна переглянути всі напої, що присутні в системі, є можливість редагувати дані напою (див. рис. 5.15) та можна створити новий напій (див. рис. 5.16-5.17).

Рисунок 5.14 – Сторінка з напоями

Рисунок 5.15 – Форма редагування напою

Рисунок 5.16 – Створення нового напою

Рисунок 5.17 – Створений напій у списку

Також є можливість пошуку напою за назвою або типом (див. рис. 5.18).

Рисунок 5.18 – Пошук напою за назвою

Далі в навігаційній панелі можна побачити вкладку «Акаунти», яка відкриває адміністратору одразу дві сторінки: «Технічні працівники» та Користувачі».
Перша сторінка з технічними працівниками (див. рис. 5.19) надає можливість зареєструвати у системі нового технічного спеціаліста. Для цього необхідно ввести електронну пошту та пароль.

Рисунок 5.19 – Створення технічного працівника

Також у адміністратора є можливість редагувати дані працівника (див. рис. 5.20) та видаляти їх акаунти. Можливий пошук працівників за іменем або електронною поштою (див. рис. 5..21).

Рисунок 5.20 – Редагування даних технічного працівника

Рисунок 5.21 – Пошук працівника за іменем

Сторінка з користувачами надає повну інформацію про вих користувачів системи (див. рис. 5.22). Тут також присутнє поле пошуку за іменем або електронною поштою.

Рисунок 5.22 – Сторінка з користувачами

На цьому з панелью адміністратора закінчено. Щоб вийти з панелі необхідно натиснути кнопку Вийти, яка перенесе нас на головну сторінку. Тепер переглянемо функціонал для технічних працівників.
Спершу необхідно авторизуватися як технічний працівник. Для цього вводимо дані працівника у поле авторизації (див. рис. 5.23).

Рисунок 5.23 – Сторінка авторизації

Після успішної авторизації відкривається панель працівника, яка надає йому інтерфейс для різноманітних дій. Тут є бокова навігаційна панель, яка дає змогу переключатися між сторінками. Перша сторінка з автоматами, яка відображає всі автомати, за які відповідальний працівник (див. рис. 5.24).

Рисунок 5.24 – Сторінка з автоматами працівника

На цій сторінці у працівника є можливість пошуку автомату за назвою та статусами автоматів (працює або не працює). Так само як і в напеці адміністратора можна відкрити детальну інформацію про автомат натиснувши кнопку «Переглянути детальніше». Після цього відкривається сторінка з детальною інформацією про автомат, де можна побачити інформацію про автомат, його параметри, статус та напої (див. рис. 5.25-5.26).

Рисунок 5.25 – Сторінка з інформацією автомата

Рисунок 5.26 – Сторінка з інформацією автомата

Наступна сторінка це профіль працівника (див. рис. 5.27).  Вона містить дані працівника, які можна змінити та деяку інформацію по графіку роботи та даним підтримки.

Рисунок 5.27 – Профіль працівника

На цьому з панелью працівника закінчено. Щоб вийти з панелі необхідно натиснути кнопку Вийти, яка перенесе нас на головну сторінку. Тепер переглянемо функціонал для користувачів системи.
Для тих користувачів які ще не зареєстровані є форма реєстрації (див. рис. 5.28) та після успішної реєстрації вони можуть перейти до форми авторизації натиснувши кнопку Увійти тут, щоб отримати повний функціонал для користувачів.

Рисунок 5.28 – Форма реєстрації

Після успішного входу користувача зустрічає сторінка з напоями (див. рис. 5.29). На цій сторінці вони можуть шукати напої за назвою, а також можуть переглянути детальну інформацію про напій натиснувши кнопку «Переглянути детальніше», яка відкриває сторінку з детальною інформацією про напій (див. рис. 5.30).

Рисунок 5.29 – Сторінка з напоями

Рисунок 5.30 – Сторінка з детальною інформацією про напій

На сторінці напою користувач може побачити таку інформацію про напій: тип кави, об’єм, ціна та опис. З правого боку відображається загальний рейтинг напою. Є можливість переглянути відгуки про напій та залишити свій. Для цього необхідно ввести рейтинг від 1 до 5 та написати коментар про напій у відповідному полі вводу та натиснути кнопку «Додати коментар» (див. рис. 5.31). Створений відгук відобразиться у списку.

Рисунок 5.31 – Створення коментаря

Наступною йде сторінка з автоматами з кавою (див. рис. 5.32). На цій сторінці можна переглянути всі автомати та відфільтрувати їх за локацією, обравши необхідне місто в фільтрі, та за статусом, працює чи не працює автомат. Натиснувши на кнопку «Переглянути напої» користувачу відкриється вікно з усіма напоями, які містяться в цьому автоматі (див. рис. 5.33).

Рисунок 5.32 – Сторінка з автоматами

Рисунок 5.33 – Вікно з напоями автомата

Останньою сторінкою йде сторінка профілю користувача (див. рис. 5.34). Тут користувач може  відредагувати свої дані (див. рис. 5.35) та видалити свій обліковий запис (див. рис. 5.36).

Рисунок 5.34 – Сторінка профілю користувача

Рисунок 5.35 – Форма редагування даних

Рисунок 5.36 – Видалення профілю

З правої сторони сторінки відображаються всі замовлення користувача (див. рис. 5.37).

Рисунок 5.37 – Замовлення користувача

Для того щоб вийти з профілю необхідно натиснути кнопку «Вийти» в навігаційному меню та це вас переведе на головну сторінку.


5.3  Опис мобільного застосунку


Мобільний застосунок був реалізований з використанням мови програмування Kotlin.
Для запуску мобільного застосунку можна використовувати симулятор Android Studio або реальний Android-пристрій. Перш ніж запускати додаток, необхідно завантажити проект у середовищі розробки, скомпілювати його та запустити на вибраному пристрої.
Мобільний застосунок призначений лише для звичайних користувачів. Після входу до додатку користувача зустрічає головна сторінка з інформацією про додаток (див. рис. 5.38). 

Рисунок 5.38 – Головна сторінка мобільного додатку

Натиснувши на кнопку «Авторизуватися» відкривається сторінка з формою для авторизації (див. рис. 5.39). Якщо користувач ще не зареєстрований тоді від може натиснути кнопку «Зареєструватися тут» та відкривається сторінка з формою для реєстрації (див. рис. 5.40). Ввівши всі необхідні дані користувач може перейти назад до форми авторизації щоб увійти до аккаунту.

Рисунок 5.39 – Сторінка авторизації

Рисунок 5.40 – Сторінка реєстрації

Після успішної авторизації користувачу відкривається сторінка з напоями (див. рис. 5.41). На цій сторінці можна переглянути всі напої що є взагалі у системі. 

Рисунок 5.41 – Сторінка з напоями

Внизу сторінки є навігаційне меню яке містить такі елементи як: напої, автомати та профіль. Натиснувши на «Автомати» відкривається сторінка з автоматами (див. рис. 5.42), де вони одразу фільтруються по регіонам. Також у фільтрі можна змінити місто (див. рис.5.43).

Рисунок 5.42 – Сторінка з автоматами

Рисунок 5.43 – Фільтрація по місту

Якщо натиснути на автомат, то відкривається вікно з усіма напоями, що містяться в цьому автоматі (див. рис. 5.44). Поруч з кожним напоєм є кнопка «Замовити», яка робить замовлення на каву.

Рисунок 5.44 – Сторінка з напоями для автомата

Повернувшись до сторінки з напоями та натиснувши на останню іконку у навігаційному барі відкривається сторінка з профілем користувача (див. рис. 5.45). 

Рисунок 5.45 – Сторінка з профілем користувача

На сторінці профілю міститься повна інформація про користувача, також є кнопка «Редагувати профіль», яка змінює дані профілю, кнопки «Видалити профіль» та «Вийти з профілю». Натиснувши останню кнопку користувач виходить з профілю та потрапляє на головну сторінку.


ВИСНОВКИ 


В ході виконання курсового проекту було придбано навички в галузі розробки програмного забезпечення. Розроблено програмну систему управління, роботи та відстеження автоматів з кавою, яка включає в себе клієнтський та мобільний застосунки, а також серверну частину.
Для реалізації системи було використано сучасні технології та інструменти, зокрема мови програмування Kotlin для мобільного застосунку, React для клієнтського веб-додатку та С#, ASP.NET Core, СУБД MS SQL Server, технологію доступу до даних ADO.NET Entity Framework для серверної частини. Для забезпечення безпеки та зручної взаємодії були використані інструменти шифрування паролів, а також сторонні бібліотеки для взаємодії з веб-сервісами.
Створена система повністю відповідає завданню, оскільки вона надає користувачам можливість з легкістю знаходити та замовляти напої з кавових автоматів, отримувати рейтинги та відгуки від інших користувачів, а також забезпечує адміністраторам та технічним працівникам зручний інтерфейс для керування автоматами та моніторингу їх стану.
Система відповідає вимогам та очікуванням, і може бути використана для покращення процесу управління кавовими автоматами та задоволення потреб користувачів.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
2. Krzystof Cwalina, Brad Abrams. Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries.–Addison-Wesley Professional, 2009. – 436 p.
3. Martin Fowler. Refactoring. Improving the Design of Existing Code– Addison-Wesley Professional, 1999. – 464 p.
4. Kotlin documentation URL: https://kotlinlang.org/docs/home.html (Дата звернення 22.05.2024)
5. Програмний код створеної системи URL: https://github.com/NureBuravkovaDaryna/apzkr-pzpi-21-6-buravkova-daryna (Дата звернення 17.06.2024)
6. Відео функціонального тестування URL: https://youtu.be/fMfBs-2oSaI (Дата звернення 19.06.2024)


ДОДАТОК А
Фрагменти коду серверної частини

А.1 Програмний код для генерації JWT


1 var tokenHandler = new JwtSecurityTokenHandler();
2    var key = Encoding.ASCII.
3       GetBytes(_appSettings.Secret);
4    var tokenDescripter = new SecurityTokenDescriptor{
5        Subject = new ClaimsIdentity(new[] 
6                { new Claim("id", user.Id.ToString()), 
7                  new Claim("email", user.Email), 
8                  new Claim(ClaimTypes.Role, user.Role) }),
9        Expires = DateTime.UtcNow.AddDays(7),
10       SigningCredentials = new SigningCredentials(
11              new SymmetricSecurityKey(key), 
12              SecurityAlgorithms.HmacSha512Signature)};
13    var token = tokenHandler.CreateToken(tokenDescripter);
14    var encrypterToken = tokenHandler.WriteToken(token);


А.2 Програмний код шифрування паролю


1 using (HMACSHA512 hmac = new HMACSHA512())
2 {
3     user.PasswordSalt = hmac.Key;
4     user.PasswordHash = hmac.ComputeHash(System.Text.Encoding.UTF8.GetBytes(model.Password));
5 }


А.3 Програмний код контролеру для напою


1 [Route("api/[controller]")]
2 [ApiController]
3 public class CoffeeController : ControllerBase
4 {
5     private readonly ICoffeeRepository _coffeeRepository;
6     private readonly IMapper _mapper;
7 
8     public CoffeeController(ICoffeeRepository coffeeRepository,
9         IMapper mapper)
10     {
11         _coffeeRepository = coffeeRepository;
12         _mapper = mapper;
13     }
14 
15     [HttpGet]
16     [ProducesResponseType(200, Type = typeof(IEnumerable<Coffee>))]
17     public IActionResult GetCoffees()
18     {
19         var Coffees = _mapper.Map<List<CoffeeDto>>(_coffeeRepository.GetCoffees());
20 
21         if (!ModelState.IsValid)
22             return BadRequest(ModelState);
23 
24         return Ok(Coffees);
25     }
26 
27     [HttpGet("{id}")]
28     [ProducesResponseType(200, Type = typeof(Coffee))]
29     [ProducesResponseType(400)]
30     public IActionResult GetCoffee(int id)
31     {
32         if (!_coffeeRepository.CoffeeExists(id))
33         {
34             ModelState.AddModelError("", "Coffee not found");
35             return BadRequest(ModelState);
36         }
37 
38         var Coffee = _mapper.Map<CoffeeDto>(_coffeeRepository.GetCoffee(id));
39 
40         if (!ModelState.IsValid)
41             return BadRequest(ModelState);
42 
43         return Ok(Coffee);
44     }
45 
46     [HttpGet("/CoffeeMachine")]
47     [ProducesResponseType(200, Type = typeof(IEnumerable<Coffee>))]
48     public IActionResult GetAvaliableCoffee()
49     {
50         var Coffees = _mapper.Map<List<CoffeeDto>>(_coffeeRepository.GetAvailableCoffees());
51 
52         if (!ModelState.IsValid)
53             return BadRequest(ModelState);
54 
55         return Ok(Coffees);
56     }


А.4 Програмний код репозиторію для роботи з автоматами


1 public class MachineRepository : IMachineRepository
2 {
3     private readonly DataContext _context;
4 
5     public MachineRepository(DataContext context)
6     {
7         _context = context;
8     }
9     public bool MachineExists(int id)
10     {
11         return _context.Machine.Any(p => p.Id == id);
12     }
13 
14     public bool CreateMachine(Machine machine)
15     {
16         _context.Add(machine);
17         return Save();
18     }
19 
20     public bool DeleteMachine(Machine machine)
21     {
22         _context.Remove(machine);
23         return Save();
24     }
25 
26     public bool DeleteMachines(List<Machine> machines)
27     {
28         _context.RemoveRange(machines);
29         return Save();
30     }
31 
32     public ICollection<Machine> GetAvailableMachines()
33     {
34         return _context.Machine.Where(e => e.IsWorking == true).ToList();
35     }
36 
37     public ICollection<Machine> GetMachinesByCoffee(int drinkId)
38     {
39         return _context.CoffeeMachine
40             .Where(p => p.Coffee.Id == drinkId).Select(p => p.Machine).ToList();
41     }
42 
43     public ICollection<Machine> GetMachinesByRegion(int regionId)
44     {
45         return _context.Machine.Include(m => m.Region)
46             .Where(e => e.Region.Id == regionId).ToList();
47     }
48 
49     public Machine GetMachine(int id)
50     {
51         return _context.Machine.Include(m => m.Region)
52             .Where(p => p.Id == id).FirstOrDefault();
53     }
54 
55     public ICollection<Machine> GetMachines()
56     {
57         return _context.Machine.Include(m => m.Region)
58             .OrderBy(p => p.Id).ToList();
59     }


ДОДАТОК Б
Фрагменти коду клієнтської частини


Б.1 Програмний код для управління напоями


1 import React, { useState, useEffect } from 'react';
2 import { Link } from 'react-router-dom';
3 import 'bootstrap/dist/css/bootstrap.min.css';
4 import './CoffeePage.css';
5 
6 function CoffeePage() {
7     const [coffeeList, setCoffeeList] = useState([]);
8     const [searchTerm, setSearchTerm] = useState('');
9 
10     useEffect(() => {
11         fetch('https://localhost:7256/api/Coffee')
12             .then(response => response.json())
13             .then(data => setCoffeeList(data))
14             .catch(error => console.error('Error fetching coffee list:', error));
15     }, []);
16 
17     const handleSearchChange = (event) => {
18         setSearchTerm(event.target.value);
19     };
20 
21     const filteredCoffeeList = coffeeList.filter(coffee =>
22         coffee.name.toLowerCase().includes(searchTerm.toLowerCase())
23     );
24 
25     return (
26         <div className="container mt-4">
27             <h2 className="text-center mb-4">Наші напої</h2>
28             <div className="row mb-4">
29                 <div className="col">
30                     <input
31                         type="text"
32                         className="form-control"
33                         placeholder="Пошук за назвою..."
34                         value={searchTerm}
35                         onChange={handleSearchChange}
36                     />
37                 </div>
38             </div>
39             <div className="row">
40                 {filteredCoffeeList.map(coffee => (
41                     <div key={coffee.id} className="col-md-4 mb-4">
42                         <div className="card">
43                             <div className="card-body">
44                                 <h5 className="card-title">{coffee.name}</h5>
45                                 <p className="card-text">Тип: {coffee.type}</p>
46                                 <Link to={`/user/coffee/${coffee.id}`} className="btn btn-primary">
47                                     Переглянути детальніше
48                                 </Link>
49                             </div>
50                         </div>
51                     </div>
52                 ))}
53             </div>
54         </div>
55     );
56 }
57 
58 export default CoffeePage;



Б.2 Програмний код функціоналу авторизації 


1 import React, { useState } from 'react';
2 import { useNavigate, Link } from 'react-router-dom';
3 import './Login.css'; 
4 
5 function Login() {
6     const [email, setEmail] = useState('');
7     const [password, setPassword] = useState('');
8     const navigate = useNavigate();
9 
10     const handleLogin = async (e) => {
11         e.preventDefault();
12         try {
13             const response = await fetch('https://localhost:7256/api/Auth/Login', {
14                 method: 'POST',
15                 headers: {
16                     'Content-Type': 'application/json',
17                 },
18                 body: JSON.stringify({ email, password }),
19             });
20 
21             if (response.ok) {
22                 const data = await response.json();
23                 localStorage.setItem('userId', data.userId); // Store user ID in local storage
24                 console.log('User ID:', data.userId); // Log the retrieved user ID
25                 const role = data.role; // Assuming response contains a role property
26                 if (role === 'Admin') {
27                     navigate('/admin/database');
28                 } else if (role === 'User') {
29                     navigate('/user/coffee'); // Redirect to profile page
30                 } else {
31                     alert('Unknown role');
32                 }
33             } else {
34                 alert('Login failed');
35             }
36         } catch (error) {
37             console.error('Error:', error);
38         }
39     };
40 
41     return (
42         <div className="form-container">
43             <div className="form-box">
44                 <h1>Ввійти в аккаунт</h1>
45                 <form onSubmit={handleLogin}>
46                     <div className="form-group">
47                         <label>Email</label>
48                         <input 
49                             type="email" 
50                             className="form-control" 
51                             value={email} 
52                             onChange={(e) => setEmail(e.target.value)} 
53                             required 
54                         />
55                     </div>
56                     <div className="form-group">
57                         <label>Password</label>
58                         <input 
59                             type="password" 
60                             className="form-control" 
61                             value={password} 
62                             onChange={(e) => setPassword(e.target.value)} 
63                             required 
64                         />
65                     </div>
66                     <button type="submit" className="btn btn-primary">
67                         Ввійти
68                     </button>
69                 </form>
70                 <p className="register-link">
71                     Ще не зареєстровані? <Link to="/register">Зареєструватися тут</Link>
72                 </p>
73             </div>
74         </div>
75     );
76 }
77 
78 export default Login;


Б.3 Програмний код навігації в веб-додатку

1 import React from 'react';
2 import { Route, Routes } from 'react-router-dom';
3 import Homepage from '../components/Home/Homepage';
4 import Login from '../components/Auth/Login';
5 import Register from '../components/Auth/Register';
6 import UserHeader from '../components/User/UserHeader';
7 import CoffeePage from '../components/User/CoffeePage';
8 import MachinesPage from '../components/User/MachinesPage';
9 import ProfilePage from '../components/User/ProfilePage';
10 import CoffeeConcretePage from '../components/User/CoffeeConcretePage';
11 import AdminNavBar from '../components/Admin/AdminNavBar';
12 import DatabasePage from '../components/Admin/DatabasePage';
13 import OrdersPage from '../components/Admin/OrdersPage';
14 import MachinesControlPage from '../components/Admin/MachinesControlPage';
15 import EmployeesPage from '../components/Admin/EmployeesPage';
16 import UsersPage from '../components/Admin/UsersPage';
17 import DrinksPage from '../components/Admin/DrinksPage';
18 import MachineDetailsPage from '../components/Admin/MachineDetailsPage';
19 import TechNavBar from '../components/Tech/TechNavBar';
20 import MachinesMonitor from '../components/Tech/MachinesMonitor';
21 import TechProfile from '../components/Tech/TechProfile';
22 import MachineControl from '../components/Tech/MachineControl';
23 
24 function AppRoutes() {
25     return (
26         <Routes>
27             <Route path="/" element={<Homepage />} />
28             <Route path="/login" element={<Login />} />
29             <Route path="/register" element={<Register />} />
30             <Route path="/user" element={<UserHeader />}>
31                 <Route path="coffee" element={<CoffeePage />} />
32                 <Route path="coffee/:id" element={<CoffeeConcretePage />} />
33                 <Route path="machines" element={<MachinesPage />} />
34                 <Route path="profile" element={<ProfilePage />} />
35             </Route>
36             <Route path="/admin" element={<AdminNavBar />}>
37                 <Route path="database" element={<DatabasePage />} />
38                 <Route path="orders" element={<OrdersPage />} />
39                 <Route path="machines" element={<MachinesControlPage />} />
40                 <Route path="machines/:id" element={<MachineDetailsPage />} />
41                 <Route path="drinks" element={<DrinksPage />} />
42                 <Route path="accounts/employees" element={<EmployeesPage />} />
43                 <Route path="accounts/users" element={<UsersPage />} />
44             </Route>
45             <Route path="/technician" element={<TechNavBar />}>
46                 <Route path="machines" element={<MachinesMonitor />} />
47                 <Route path="machines/:id" element={<MachineControl />} />
48                 <Route path="profile" element={<TechProfile />} />
49             </Route>
50         </Routes>
51     );
52 }
53 
54 export default AppRoutes;


ДОДАТОК В
Фрагменти коду мобільного додатку

В.1 Програмний код обробки реєстрації користувача


1 class RegisterActivity : AppCompatActivity() {
2 
3     private lateinit var authApi: AuthApi
4 
5     override fun onCreate(savedInstanceState: Bundle?) {
6         super.onCreate(savedInstanceState)
7         setContentView(R.layout.activity_register)
8 
9         val retrofit = Retrofit.Builder()
10             .baseUrl("https://localhost:7256/")
11             .addConverterFactory(GsonConverterFactory.create())
12             .build()
13 
14         authApi = retrofit.create(AuthApi::class.java)
15 
16         val buttonRegister = findViewById<Button>(R.id.buttonRegister)
17         buttonRegister.setOnClickListener {
18             register()
19         }
20 
21         val textViewLoginLink = findViewById<TextView>(R.id.textViewLoginLink)
22         textViewLoginLink.setOnClickListener {
23             // Перехід на сторінку авторизації
24             onBackPressed()
25         }
26     }


В.2 Програмний код адаптера для відображення списку кавових автоматів


1 class MachineAdapter(private val onItemClick: (Machine) -> Unit) :
2     ListAdapter<Machine, MachineAdapter.MachineViewHolder>(MachineDiffCallback()) {
3 
4     override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MachineViewHolder {
5         val view = LayoutInflater.from(parent.context).inflate(R.layout.item_machine, parent, false)
6         return MachineViewHolder(view, onItemClick)
7     }
8 
9     override fun onBindViewHolder(holder: MachineViewHolder, position: Int) {
10         val machine = getItem(position)
11         holder.bind(machine)
12     }
13 
14     class MachineViewHolder(itemView: View, val onItemClick: (Machine) -> Unit) : RecyclerView.ViewHolder(itemView) {
15         private val nameTextView: TextView = itemView.findViewById(R.id.nameTextView)
16         private val addressTextView: TextView = itemView.findViewById(R.id.addressTextView)
17         private val statusTextView: TextView = itemView.findViewById(R.id.statusTextView)
18 
19         fun bind(machine: Machine) {
20             nameTextView.text = machine.name
21             addressTextView.text = machine.address
22             statusTextView.text = if (machine.isWorking) "Працює" else "Не працює"
23 
24             itemView.setOnClickListener {
25                 onItemClick(machine)
26             }
27         }
28     }
29 
30     private class MachineDiffCallback : DiffUtil.ItemCallback<Machine>() {
31         override fun areItemsTheSame(oldItem: Machine, newItem: Machine): Boolean {
32             return oldItem.id == newItem.id
33         }
34 
35         override fun areContentsTheSame(oldItem: Machine, newItem: Machine): Boolean {
36             return oldItem == newItem
37         }
38     }
39 }


В.3 Програмний код для управління відображенням та пошуком напоїв


1 class CoffeeFragment : Fragment() {
2 
3     private var _binding: FragmentCoffeeBinding? = null
4     private val binding get() = _binding!!
5 
6     private val coffeeViewModel: CoffeeViewModel by viewModels()
7 
8     override fun onCreateView(
9         inflater: LayoutInflater, container: ViewGroup?,
10         savedInstanceState: Bundle?
11     ): View? {
12         _binding = FragmentCoffeeBinding.inflate(inflater, container, false)
13         return binding.root
14     }
15 
16     override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
17         super.onViewCreated(view, savedInstanceState)
18 
19         val adapter = CoffeeAdapter()
20         binding.recyclerView.apply {
21             layoutManager = LinearLayoutManager(requireContext())
22             this.adapter = adapter
23         }
24 
25         coffeeViewModel.coffees.observe(viewLifecycleOwner, Observer { coffees ->
26             coffees?.let {
27                 adapter.submitList(it)
28             }
29         })
30 
31         coffeeViewModel.error.observe(viewLifecycleOwner, Observer { error ->
32             error?.let {
33                 Toast.makeText(requireContext(), it, Toast.LENGTH_LONG).show()
34             }
35         })
36 
37         // Викликаємо метод для отримання кави з API
38         coffeeViewModel.fetchCoffees()
39 
40         // Додаємо прослуховувач для поля пошуку
41         binding.searchEditText.addTextChangedListener(object : TextWatcher {
42             override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
43                 // Not needed
44             }
45 
46             override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
47                 // Not needed
48             }
49 
50             override fun afterTextChanged(s: Editable?) {
51                 val searchText = s.toString().lowercase()
52                 val filteredList = coffeeViewModel.coffees.value?.filter {
53                     it.name.lowercase().contains(searchText)
54                 }
55                 adapter.submitList(filteredList)
56             }
57         })
58     }
59 
60     override fun onDestroyView() {
61         super.onDestroyView()
62         _binding = null
63     }
64 }

ДОДАТОК Г
Результат перевірки роботи на антиплагіат
